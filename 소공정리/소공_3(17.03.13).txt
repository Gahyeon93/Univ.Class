2017.03.13 6th

<review> 00:00:00~
	
	~, 인슐린펌프, 구조, 크리티컬 시스템일 경우 금전적 차이가 크더라도 비싼거 쓴다. 의존성.
	네가지 요소 + 네가지요소, 핵심은 slide 14. 유지보수는 스킵. 의존성을 높이다보면 퍼포먼스는 떨어질 수 밖에 없다. (상용코드에서는 생각을 많이 해야하는데, ex 알고리즘적으로.. ). 그래프. slide 21 : 해석./ 나중에 프로그램을 기획할 일이 있을 때, critical적인 부분을 감안해서 가격과 안정성을 미리 예측하고 고려하는 고민을 해야 될것이다. p.22 reliability : 주어진 시간에 ailure-free. ㅁㅍ먀ㅣㅁ퍄ㅣㅑ쇼 : 우너할 때 접속이 가능해야함. 두 개 다른거임. 근데 또 완전히 다르기보다 어느정도 연관성이 있다.

p.23 // 16:27~
	available하더라도 reliable하지 못할 수도. 예전에는 전화에 교환원이 있었음. 아무래도 실수가 있을 수 있다. 교환원이 통화중이면 available 안한 것. 사람이니까 실수가 있으면 available하지만 reliable하지 못한 것.(전화교환은 크리티컬 아니긴 하지만..)
	failure하더라도 빠르게 repair가능하고 데미지가 적다면 low re~는 문제가 아니다.
	ex) 그 당시 피쳐폰 시스템이 매우 좋지 않았는데, 음성인식 시스템을 탑재하려는 것이 매우 힘들어서 전세계적으로 솔루션을 제공하는 곳이 없었다. -> 그 중에 제안된 솔루션은 reliability를 낮추는 것이었다. critical system이 아니기 때문에 가능.

p.24 //23:30~ 시험낸다면 헷갈리겠지
	system fault : 시스템 에러를 야기시키는 특성. ex 변수초기화,
	system error : 사용자가 예측할 수 없는 상태로.. state.
	system failure : 특정 순간에 사용자가 기대한대로 서비스가 deliver되지 않는 상태.
	H~ (별로 안중요. 읽기만)
p.25 // 25:45
	failure는 시스템에러로 인한 결과.
	error가 항상 시스템 페일러를 이끄는 것은 아니다.
		잘못된 시스탬 상테가 있더라도 corrected 될 수 있다. 여러가지 방면으로 수정이 가능할수있음
		ex 도서관 책 찾기 등 다시시도, 통신같으면 실패를 알리기 전에 한 번 더 시도하는 등.
	
p.26 제외

p.27 (새 녹음 3.2)
	이런 것들을 모두 고려하기 힘들 수 있지만, 고려하지 못할 경우 쌓이고 쌓이면..

	fault avoidance : 코딩할 때 잘하는 법도 있지만,, ex 대표적으로 VS 이용할 때, 디버그 모드에서 컴파일러 돌리면 추적해서 잘못된 거 찾아주는 등. 회피방법 있음. 툴을 사용해서 모든 warning을 표시해서 모두 해결. 그리고 습관도 중요함. 메모리 allocation을 쓸 때 항상 체크하는 등. debug모드와 release모드 모두 체크 등.

	fault detection and removal : ~~. 중간에 저장하고 그런것이 쉽지 않을 수 잇지만 신경써야함.

	Fault tolerance : 쉽지 않지만 잘 되면 경쟁력이 있을겁니다.

p.28  //5:18
	많이 중요한 것 같지 않지만.. 간단하게 설명하면 어떤 시스템의 문제를 확률적으로 바라본다.
	사용자에 따라 오류가 다를 수다. 다음 그림을 보자
p.29
p.30 
	다양한 입력이 있는데 유저마다 사용하는 부분이 다르지만, 세명이서 테스트해도 발견되지 않는 부분이 있을 수 있음...인원이 많아질 수록 에러를 더 잘 디텍트할수 있다면 좋을텐데, 보통은 기본 기능에만 몰려있게됨.
->p.31
	전체 기능 중 x%를 해결하더라도 reliavility가 x%오르는 것이 아님. 전체 관점에서는 많이 버그한 것 같지만, 실 사용에서는 느끼지 못한다.(에러부분을 잘 사용하지 않기 때문에)
	체감 reliablilty는 크지 않다.
	잘 알려진 문제점은 생각보다 reliable하게 받아드릴 수도(이건 별로 안중요한듯)

12:15 ~ 16:33(유지보수가 어렵게 코딩하는 방법)


p.32 //
	Safety : 읽어보면 크게 어렵지 않음.
p.33 //~18:30
	Safety Criticality
	Pri~ : 직접적으로 영향을 미침. "directily"
	Second : 다른 시스템에서 문제. ex 디자인의 오류 등.
	Dis~ : 읽ㅇ..

p.34
	읽으면 다 당연한 얘기 같은데...시험보면 어려워 ㅠ 
	Safety, Rel~ 이것도 구분이 된다는 말임. 간단하게 얘기하면, 아니다 그냥 넘어가자. 시험ㄴㄴ

p.35 //20:30~
	특별한 상황
	unsafe한데 reliavle할 수 있다. 스펙데로 시스템이 돌아가지만 safety하지 않는 경우 즉, 시스템의 specification이 잘못되어 있는 경우이다. ex. 사용자가 원하는 소프트웨어를 개발할 때, 소프트웨어가 사용될 분야에 대한 지식이 충분하지 못할 수 있다. 그러면 스팩을 정하는 단계에서 상대방이 원하는 것을 정확하게 캐치할 수 없을 수 있다. 다 만든 후에 서로 생각한 것이 다른 것..(이런 경우 생각해서 계약서 잘 써야함.)
	하드웨어가 잘못되어서 이상한 인풋을 만들어낼 때, 예측하기 힘듦.
	컨텍스트~ : 잘못된 시간에 바른 명령을 하는 경우. ex 비행이를 공중에서~`

p.36 // 25:13~
	accident : 읽어주심. 
	Hazard : ~
	Damage : 얼마나 손실을 받는지에 대한 측정. ~~
	그 밑은 확인해보면 됨.
	마지막으로 risk : 얼마나 위험이 있는지에 대한 확률..
p.37 //27:38
	최대한 회피. : Ex)위험한 작동은 버튼을 동시에 눌러야만 동작하게끔 등.
	디텍션 후 제거  
	데미지 제한적으로. Ex) 아이언맨 같은 거..반대로 꺾으면;; 물리적으로 제한을 둘 수 있음. 엘레베이터 : 급속도일 때 작동하는 브레이크 등.
	
p.38 //32:00~
	단순히 하나만 문제되서 사고가 발생하는 경우는 거의 없다. 
	잘못된 조건이 어디서는 정상적인 조건이어서 디텍션하기 어려운 경우도 있음.
	완벽하게 ~는 불가능하다.
	(갑자기 드는 생각. Ex. 간단해서 절대 버그날 수 없다 생각했는데.. 버그가 나서 누가 문제인지 시시비비를 가려야 할 때...자기 문제 아니라고 회의안하고 가는 사람 있기도 하는데..ㅎ 아무리 간단하더라도 믿지 말고 모든 가정을 생각하고 버그잡자.)

p.39 // 36:30~
	Security
	protect! 카드사 이슈부터 과거에 많은 문제들이 발생해왔지.
	(민감한 얘기일 수 잇는데..1학년 친구들은 보안쪽 가고싶어하는 사람이 많은데.. 보안은 돈을 벌기보다는 돈을 쓰는 직업이지..보안에 관심있으면 신중히 고려해보길..아님 정말 메이저업체로 들어가야.. 안랩도 순위가 높지 않음.)
	
p.41
	expo~
	attack
	control 읽어보면 됨.
p.42, p43. 
	그래서 insecurtiy한 시스템에선 service, corrup~, dis~ 등 발생할 수 있음.
	
	