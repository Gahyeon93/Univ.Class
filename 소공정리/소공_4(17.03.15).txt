software Process

p.4 The Software Process
	나와있는 것처럼 등등을 개발합니다. 큰 회사의 경우는 개인이 무슨 단계인지 생각하지 않아도 알아서 진행이 되겠지만 아닌 곳은 어떤 과정을 통해서 개발하는지 잘 파악해야함.
	신기술 등을 개발할 때, '숫자' 등을 정하기 힘들어서 쉽지 않다

p.5 //6:30~
	Waterfall 모델 : 해석. 즉 앞의 과정을 이용해 개발하는데, 워터풀은 현재 시점이 무슨 과정인지 명확한 경우를 말한다.
	evo~ : 
	con~: 이걸 잘하는 학생이 성적을 잘받는 경우가 많음. 기존의 component를 잘 조합해서 만드는 것.
	-이 세가지 모델에 정확히 맞춰지지 않고.. 큰 프로젝트의 경우 워터폴모델이 기반이지만 그 안에서 쪼개진 팀은 또 다른 방법론을 사용하기도 함. 꼭 하나를 고수할 필요없읍

p.6 //11:26~
	이러한 과정으로 구현된다.
p.7
	이런 단계도 일반적인 것이지 중간에 뭐 추가될 수 할 수 있음. 중요한건 각 단계가 끝나고 다음 단계로 넘어간다는 것임. 
	다음 단계로 나가기 위해서는 하나의 단계가 끝나야함. 단점은 특정 단계에서 오류가 나면 모든 단계의 처음으로 돌아가야 할 수도.
	+ 대신 좋은 점(?)은 각 단계를 완전히 끝내고 넘어가기 때문에 (진화모델은 계속 돌면서하는데) 각 단계에 문서를 남기게 되면 확인하기가 좋음.

p.8 문제점들
	customer가 requirement를 바꾸면 힘들다.
	따라서 변화가 없는 경우에 사용한다.
	큰 시스템에서 주로 사용한다.

p.9 //17:40~
	<진화적인 개발 방법>
	계속 피드백을 주고 받으면서 진화적으로 개발하는 방법이다.
	- 탐험적방법
		커스터머와 같이 일을 한다. 처음부터 마지막까지. 처음에 잘 알려진 require부터 하고.. 점차 새로운 특징을 더해감. 뒤에 그림 보면, 각각의 단계에서 우측 사각형(initial, , )이 나오게 됨.
	- ~ 프로토타입
		시스템 requirement를 이해하기 위함. 위와 다른건 시작은 '잘 모르는 requirement부터'시작한다. (프로토타입은 개발 목표가 아니지) 만들어보면서 이해하고 throw away 버리는거지.

p.11 //22:50~
	
	lack of precess visibility : 워터풀은 진행이 어느정도 되는지 과정에 따라서 알 수 있음. 근데 이거는 어디까지 했는지 어떤 단계인지 정의하기 힘들고 눈에 보이지 않음.
	system이 종종 구현되지 않음
	그래서 특별한 능력이 필요함
	
	small or medium 의 시스템에 좋음
	~
	~

	책에는 없지만 현실적으로 어려운 점은... 커스터머와 같이 일하는 것이 쉽지 않음.
	(기록이 중요함.~~~~)

p. 12 32:40~
	뒤에 다시 나오긴 할건데, 말그대로 외부의 component를 이용해서 구현하는 것. 프로세스관점에서만 먼저 보겠습니다.
 
	처음에 component analysis함.
	requirement modification : 기존 컴포넌트를 이용하기 위해 변형
	reuse
	
	약간의 requirement의 변형은 불가피하다. 장점은 기존 컴포넌트이기 때문에 검증되어 있어 테스트 시간이 절약된다. 즉 개발의 리스크가 줄어든다. 그리고 빨리 만들 수도 있다.(교수님은 이게 장점인가 잘 모르겠다. cost 같은 경우는 component가 쌀 수도 비쌀 수도 있음.)

p.13 38:30~

	방금 이야기한거 나열한거

p.14 39: 27~

	chap.4.2
	항상 시스템 리콰이어먼트는 계속해서 바뀐다. 의역하자면 시간이 지남에 따라 계속 바뀔 수 밖에 없다.
	두가지가 있음.
p.15
	incremental delivery : (delivery의 의미..결과물 같은 의미로 생각하면 될듯.)
	싱글 딜리버리 : 5개월간 개발하다가 마지막에 짠 보여주기.
	전체적으로 설명하자면, 최종적인 결과에서 분할을 한 후 하나씩 결과물을 전달하는 것. 개발뿐 아니라 커스터머에게 제공하는 것까지.

	처음에는 가장 중요한 것들 먼저 구현하고, (장점은 뒤에서 얘기하겠음)..... 먼저 진행할 기능이 한번 정해지면 수정없이 쭉 감 그다음 다음꺼. 전체적으로 계속 돌면서 함

p.16 45:40~
	대략적인 requirement 정의 -> -> -> ... 일반적인 개발 방법임. 그리고 다시 돌아가는 화살표 있지. 이렇게 계속 반복되고 마침.

	이런 그림그리라는 문제는 낸 적없지만.. 순서 쓰는 문제 낸 적 있음. 단계가 너무 많은 것들은 변형도 많고,,답이라고 하기 좀 그럼. 그러니 어느정도 정형화된 부분을 문제낼 수 있음 . 이 경우는 순서맞추기 등.

p.17  48:10
	장점
	-중간중간 확인받아서 일찍~
	-프로토타입이 만들어져서 요구를 이해하는데 도움이됨
	-로우 리스크
	-개발 다 끝나고 유지보수 요구가 들어올 수도. 이 방법론은 중요한 부분을 먼저 하기 때문에 그런 경우에 유리함.

p.18  53:00 생략.
p.19 20페이지 그림이랑 같이보자
	달팽이처럼 계속 돌아서 진행. 음 이건 그냥 참고삼아 알고 넘 어가자

p.22 55:35
	각각에 대해서 살펴보자. 반복적이긴 한데.. 더 길게 이야기 해보자

p.23 
	-~
	- 네가지 단계를 거침. 뒤에 그림을 보자.
p.24
	feasibility study : 이게 가능한가? 알아보는거. 진보된 기술일 수록 개발이 쉽지 않겠지.
	이건 대략적 가이드라인이고, 단계별로 나눠서 안할 수 있음. 해석해석해석.
	system model이라는 말이 나오는데, 앞에 단계보면(p.22) 디자인과 임필리멘테이션.. 이걸 안할 수 없는데 ~~~ 

p.25 1:1:30
	이게 뭐하는 단계인지 알텐데... 실제로 실행가능한 시스템으로 만드는 단계. 디자인 : 소프트웨어 구조. 임플리멘테이션 :..사례를 얘기해주면, 뒤에 얘기해주겠지만 미리 얘기하면, 이런 관점에서 프로젝트 해보길. 우리 팀이 네명이면, 역량이 4가 되지 않음. 1.몇..?ㅎ 이런 일이 왜 생겼을까? 소프트웨어 디자인이 정확하지 않았기 때문에...모 회사에서 일하는데, 어떤 함수를 왜 만드는지 모르겠다던 사람이 있었음. 잘 생각해보면 그게 디자인이 정말 잘돼서 잘 나눠놔서 그런 것임. 

p.26 1:8:30
	이런 단계를 거치게 되겠습니다. 정말 구체적으로 어던 알고리즘이 돌아가는 지 알아야함. p.27보면
	dkfrhflwma elwkdlsdptj dlsxjvpdltm 디자인으로 돌아갈 수도 있음.뒤에 4가지까지 다 완성해야 디자인이 끝난거임.













